{"version":3,"sources":["../../../src/webpack/util/getAffectedModuleIds.js"],"names":["getAffectedModuleIds","isBuilt","module","built","getId","id","affectedModules","map","usageMap","affected","moduleId","usages","ids","forEach","buildModuleMap","modules","moduleMap","reduce","memo","buildModuleUsageMap","chunks","moduleUsageMap","dependencies","dependency","dependentModule","chunkModuleMap","chunk","getChunks","blocks","filter","block","chunkGroup","chunkId","childModule","builtModules","affectedMap"],"mappings":";;;;;;;;;;;;;;;;;;;;;;kBA8HwBA,oB;;;;AAtHxB,IAAMC,UAAU,SAAVA,OAAU,CAACC,MAAD;AAAA,SAA6BA,OAAOC,KAApC;AAAA,CAAhB;;AACA,IAAMC,QAAQ,SAARA,KAAQ,CAACF,MAAD;AAAA,SAAkCA,OAAOG,EAAzC;AAAA,CAAd;;AAEA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACC,GAAD,EAAiBC,QAAjB,EAA2CC,QAA3C,EAAgEC,QAAhE,EAA8F;AACpH,MAAI,OAAOD,SAASC,QAAT,CAAP,KAA8B,WAAlC,EAA+C;AAC7C;AACA;AACD;AACD;AACA,MAAMR,SAASK,IAAIG,QAAJ,CAAf;AACAD,WAASP,OAAOG,EAAhB,IAAsBH,MAAtB,CAPoH,CAOtF;;AAE9B;AACA,MAAMS,SAASH,SAASN,OAAOG,EAAhB,CAAf;AACA,MAAI,OAAOM,MAAP,KAAkB,WAAtB,EAAmC;AACjC,QAAMC,MAAM,oBAAYD,MAAZ,CAAZ;AACAC,QAAIC,OAAJ,CAAY,UAACR,EAAD;AAAA,aAAgBC,gBAAgBC,GAAhB,EAAqBC,QAArB,EAA+BC,QAA/B,EAAyCJ,EAAzC,CAAhB;AAAA,KAAZ;AACD;AACF,CAfD;;AAiBA;;;;;;AAMA,IAAMS,iBAAiB,SAAjBA,cAAiB,CAACC,OAAD,EAAuC;AAC5D,MAAMC,YAAYD,QAAQE,MAAR,CAAe,UAACC,IAAD,EAAOhB,MAAP;AAAA,sCAAgCgB,IAAhC,oCAAuChB,OAAOG,EAA9C,EAAmDH,MAAnD;AAAA,GAAf,EAA6E,EAA7E,CAAlB;AACA,SAAOc,SAAP;AACD,CAHD;;AAKA;;;;;;;;;;;;AAYA,IAAMG,sBAAsB,SAAtBA,mBAAsB,CAACC,MAAD,EAAuBL,OAAvB,EAAkE;AAC5F;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMM,iBAAiCN,QAAQE,MAAR,CAAe,UAACC,IAAD,EAAOhB,MAAP,EAA0B;AAC9EA,WAAOoB,YAAP,CAAoBT,OAApB,CAA4B,UAACU,UAAD,EAAgB;AAC1C,UAAMC,kBAAkBD,WAAWrB,MAAnC;;AAEA,UAAI,CAACsB,eAAL,EAAsB;AACpB;AACD;AACD,UAAI,OAAON,KAAKM,gBAAgBnB,EAArB,CAAP,KAAoC,WAAxC,EAAqD;AACnDa,aAAKM,gBAAgBnB,EAArB,IAA2B,EAA3B,CADmD,CACpB;AAChC;AACDa,WAAKM,gBAAgBnB,EAArB,EAAyBH,OAAOG,EAAhC,IAAsCH,MAAtC,CAT0C,CASI;AAC/C,KAVD;AAWA,WAAOgB,IAAP;AACD,GAbsC,EAapC,EAboC,CAAvC;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,iBAAiCL,OAAOH,MAAP,CAAc,UAACC,IAAD,EAAOQ,KAAP,EAAwB;AAC3E;AACAR,SAAKQ,MAAMrB,EAAX,IAAiB,EAAjB,CAF2E,CAEtD;AACrB,WAAOa,IAAP;AACD,GAJsC,EAIpC,EAJoC,CAAvC;AAKAH,UAAQE,MAAR,CAAe,UAACC,IAAD,EAAOhB,MAAP,EAA0B;AACvCA,WAAOyB,SAAP,GAAmBd,OAAnB,CAA2B,UAACa,KAAD,EAAkB;AAC3CR,WAAKQ,MAAMrB,EAAX,EAAeH,OAAOG,EAAtB,IAA4BH,MAA5B,CAD2C,CACP;AACrC,KAFD;AAGA,WAAOgB,IAAP;AACD,GALD,EAKGO,cALH;;AAOA;AACAV,UAAQF,OAAR,CAAgB,UAACX,MAAD,EAAoB;AAClCA,WAAO0B;AACP;AADA,KAEGC,MAFH,CAEU,UAACC,KAAD;AAAA,aAAWA,MAAMC,UAAN,IAAoB,IAA/B;AAAA,KAFV,EAGGlB,OAHH,CAGW,UAACiB,KAAD,EAAW;AAClB;AACA;AACAA,YAAMC,UAAN,CAAiBX,MAAjB,CAAwBb,GAAxB,CAA4BH,KAA5B,EAAmCS,OAAnC,CAA2C,UAACmB,OAAD,EAAa;AACtD;AACA,8BACWP,eAAeO,OAAf,CADX,EAEGnB,OAFH,CAEW,UAACoB,WAAD,EAAsB;AAC7B,cAAI,OAAOZ,eAAeY,YAAY5B,EAA3B,CAAP,KAA0C,WAA9C,EAA2D;AACzDgB,2BAAeY,YAAY5B,EAA3B,IAAiC,EAAjC;AACD;AACDgB,yBAAeY,YAAY5B,EAA3B,EAA+BH,OAAOG,EAAtC,IAA4CH,MAA5C;AACD,SAPH;AAQD,OAVD;AAWD,KAjBH;AAkBD,GAnBD;;AAqBA,SAAOmB,cAAP;AACD,CAhED;;AAkEA;;;;;;;;;AASe,SAASrB,oBAAT,CAA8BoB,MAA9B,EAAoDL,OAApD,EAAoG;AACjH,MAAMC,YAAuBF,eAAeC,OAAf,CAA7B;AACA,MAAMM,iBAAiCF,oBAAoBC,MAApB,EAA4BL,OAA5B,CAAvC;;AAEA,MAAMmB,eAAenB,QAAQc,MAAR,CAAe5B,OAAf,CAArB;AACA,MAAMkC,cAAyB,EAA/B;AACAD,eAAarB,OAAb,CAAqB,UAACX,MAAD;AAAA,WAAoBI,gBAAgBU,SAAhB,EAA2BK,cAA3B,EAA2Cc,WAA3C,EAAwDjC,OAAOG,EAA/D,CAApB;AAAA,GAArB;;AAEA,SAAO,sBAAc8B,WAAd,EAA2B5B,GAA3B,CAA+BH,KAA/B,CAAP;AACD","file":"getAffectedModuleIds.js","sourcesContent":["// @flow\nimport type { Module, Chunk } from '../types';\n\ntype ModuleMap = { [key: string | number]: Module };\ntype ModuleUsageMap = {\n  // child id\n  [key: string | number]: ModuleMap,\n};\nconst isBuilt = (module: Module): boolean => module.built;\nconst getId = (module: any): number | string => module.id;\n\nconst affectedModules = (map: ModuleMap, usageMap: ModuleUsageMap, affected: ModuleMap, moduleId: string | number) => {\n  if (typeof affected[moduleId] !== 'undefined') {\n    // module was already inspected, stop here otherwise we get into endless recursion\n    return;\n  }\n  // module is identified as affected by this function call\n  const module = map[moduleId];\n  affected[module.id] = module; // eslint-disable-line no-param-reassign\n\n  // next we need to mark all usages aka parents also as affected\n  const usages = usageMap[module.id];\n  if (typeof usages !== 'undefined') {\n    const ids = Object.keys(usages);\n    ids.forEach((id: string) => affectedModules(map, usageMap, affected, id));\n  }\n};\n\n/**\n * Builds a map where all modules are indexed by it's id\n * {\n *   [moduleId]: Module\n * }\n */\nconst buildModuleMap = (modules: Array<Module>): ModuleMap => {\n  const moduleMap = modules.reduce((memo, module: Module) => ({ ...memo, [module.id]: module }), {});\n  return moduleMap;\n};\n\n/**\n * Builds a map with all modules that are used in other modules (child -> parent relation)\n *\n * {\n *  [childModuleId]: {\n *    [parentModuleId]: ParentModule\n *  }\n * }\n *\n * @param modules Array<number>\n * @return ModuleUsageMap\n */\nconst buildModuleUsageMap = (chunks: Array<Chunk>, modules: Array<Module>): ModuleUsageMap => {\n  // build a map of all modules with their parent\n  // {\n  //    [childModuleId]: {\n  //      [parentModuleId]: ParentModule\n  //    }\n  // }\n  //\n  const moduleUsageMap: ModuleUsageMap = modules.reduce((memo, module: Module) => {\n    module.dependencies.forEach((dependency) => {\n      const dependentModule = dependency.module;\n\n      if (!dependentModule) {\n        return;\n      }\n      if (typeof memo[dependentModule.id] === 'undefined') {\n        memo[dependentModule.id] = {}; // eslint-disable-line no-param-reassign\n      }\n      memo[dependentModule.id][module.id] = module; // eslint-disable-line no-param-reassign\n    });\n    return memo;\n  }, {});\n\n  // build a map of all chunks with their modules\n  // {\n  //    [chunkId]: {\n  //      [moduleId]: Module\n  //    }\n  // }\n  const chunkModuleMap: ModuleUsageMap = chunks.reduce((memo, chunk: Chunk) => {\n    // build chunk map first to get also empty chunks (without modules)\n    memo[chunk.id] = {}; // eslint-disable-line no-param-reassign\n    return memo;\n  }, {});\n  modules.reduce((memo, module: Module) => {\n    module.getChunks().forEach((chunk: Chunk) => {\n      memo[chunk.id][module.id] = module; // eslint-disable-line no-param-reassign\n    });\n    return memo;\n  }, chunkModuleMap);\n\n  // detect modules with code split points (e.g. require.ensure) and enhance moduleUsageMap with that information\n  modules.forEach((module: Module) => {\n    module.blocks\n    // chunkGroup can be invalid in in some cases\n      .filter((block) => block.chunkGroup != null)\n      .forEach((block) => {\n        // loop through all generated chunks by this module\n        // $FlowFixMe - flow thinks that block.chunkGroup could be null\n        block.chunkGroup.chunks.map(getId).forEach((chunkId) => {\n          // and mark all modules of this chunk as a direct dependency of the original module\n          Object\n            .values((chunkModuleMap[chunkId]: ModuleMap))\n            .forEach((childModule: any) => {\n              if (typeof moduleUsageMap[childModule.id] === 'undefined') {\n                moduleUsageMap[childModule.id] = {};\n              }\n              moduleUsageMap[childModule.id][module.id] = module;\n            });\n        });\n      });\n  });\n\n  return moduleUsageMap;\n};\n\n/**\n * Builds a list with ids of all affected modules in the following way:\n *  - affected directly by a file change\n *  - affected indirectly by a change of it's dependencies and so on\n *\n * @param chunks Array<Chunk>\n * @param modules Array<Module>\n * @return {Array.<number>}\n */\nexport default function getAffectedModuleIds(chunks: Array<Chunk>, modules: Array<Module>): Array<number | string> {\n  const moduleMap: ModuleMap = buildModuleMap(modules);\n  const moduleUsageMap: ModuleUsageMap = buildModuleUsageMap(chunks, modules);\n\n  const builtModules = modules.filter(isBuilt);\n  const affectedMap: ModuleMap = {};\n  builtModules.forEach((module: Module) => affectedModules(moduleMap, moduleUsageMap, affectedMap, module.id));\n\n  return Object.values(affectedMap).map(getId);\n}\n"]}