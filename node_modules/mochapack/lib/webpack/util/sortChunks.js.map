{"version":3,"sources":["../../../src/webpack/util/sortChunks.js"],"names":["sortChunks","chunks","chunkGroups","nodeMap","forEach","chunk","id","edges","reduce","result","chunkGroup","concat","parentsIterable","parentGroup","sortedGroups","toposort","array","sortedChunks","map","filter","index","self","exists","unique","indexOf"],"mappings":";;;;;;;;;;kBAGwBA,U;;AAHxB;;;;;;AACA;;AAEe,SAASA,UAAT,CAAoBC,MAApB,EAA4BC,WAA5B,EAAyC;AACtD;AACA,MAAMC,UAAU,EAAhB;;AAEAF,SAAOG,OAAP,CAAe,UAACC,KAAD,EAAW;AACxBF,YAAQE,MAAMC,EAAd,IAAoBD,KAApB;AACD,GAFD;;AAIA;AACA,MAAME,QAAQL,YAAYM,MAAZ,CAAmB,UAACC,MAAD,EAASC,UAAT;AAAA,WAC/BD,OAAOE,MAAP,CAAc,oBAAWD,WAAWE,eAAtB,EAAuC,UAACC,WAAD;AAAA,aAAiB,CAACA,WAAD,EAAcH,UAAd,CAAjB;AAAA,KAAvC,CAAd,CAD+B;AAAA,GAAnB,EACuF,EADvF,CAAd;AAEA,MAAMI,eAAeC,mBAASC,KAAT,CAAed,WAAf,EAA4BK,KAA5B,CAArB;AACA;AACA,MAAMU,eAAeH,aAClBN,MADkB,CACX,UAACC,MAAD,EAASC,UAAT;AAAA,WAAwBD,OAAOE,MAAP,CAAcD,WAAWT,MAAzB,CAAxB;AAAA,GADW,EAC+C,EAD/C,EAElBiB,GAFkB,CAEd,UAACb,KAAD;AAAA,WAAW;AACdF,cAAQE,MAAMC,EAAd;AADG;AAAA,GAFc,EAIlBa,MAJkB,CAIX,UAACd,KAAD,EAAQe,KAAR,EAAeC,IAAf,EAAwB;AAC9B;AACA,QAAMC,SAAS,CAAC,CAACjB,KAAjB;AACA;AACA,QAAMkB,SAASF,KAAKG,OAAL,CAAanB,KAAb,MAAwBe,KAAvC;AACA,WAAOE,UAAUC,MAAjB;AACD,GAVkB,CAArB;AAWA,SAAON,YAAP;AACD","file":"sortChunks.js","sourcesContent":["import toposort from 'toposort';\n// see https://github.com/jantimon/html-webpack-plugin/blob/8131d8bb1dc9b185b3c1709264a3baf32ef799bc/lib/chunksorter.js\n\nexport default function sortChunks(chunks, chunkGroups) {\n  // We build a map (chunk-id -> chunk) for faster access during graph building.\n  const nodeMap = {};\n\n  chunks.forEach((chunk) => {\n    nodeMap[chunk.id] = chunk;\n  });\n\n  // Add an edge for each parent (parent -> child)\n  const edges = chunkGroups.reduce((result, chunkGroup) =>\n    result.concat(Array.from(chunkGroup.parentsIterable, (parentGroup) => [parentGroup, chunkGroup])), []);\n  const sortedGroups = toposort.array(chunkGroups, edges);\n  // flatten chunkGroup into chunks\n  const sortedChunks = sortedGroups\n    .reduce((result, chunkGroup) => result.concat(chunkGroup.chunks), [])\n    .map((chunk) => // use the chunk from the list passed in, since it may be a filtered list\n      nodeMap[chunk.id])\n    .filter((chunk, index, self) => {\n      // make sure exists (ie excluded chunks not in nodeMap)\n      const exists = !!chunk;\n      // make sure we have a unique list\n      const unique = self.indexOf(chunk) === index;\n      return exists && unique;\n    });\n  return sortedChunks;\n}\n"]}