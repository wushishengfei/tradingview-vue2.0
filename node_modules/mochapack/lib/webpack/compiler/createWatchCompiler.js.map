{"version":3,"sources":["../../../src/webpack/compiler/createWatchCompiler.js"],"names":["createWatchCompiler","noop","undefined","compiler","watchOptions","createWatcher","Watching","watchCompiler","watch","times","watchFileSystem","watcher","getTimes","length","timesMap","map","key","fileTimestamps","contextTimestamps","close","pause","getWatchOptions","aggregateTimeout"],"mappings":";;;;;;;;;;;;;;;;;;kBAgBwBA,mB;;AAdxB;;;;;;AAaA,IAAMC,OAAO,SAAPA,IAAO;AAAA,SAAMC,SAAN;AAAA,CAAb;AACe,SAASF,mBAAT,CAA6BG,QAA7B,EAAiDC,YAAjD,EAAkF;AAC/F;AACA;AACA,MAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,WAAM,IAAIC,kBAAJ,CAAaH,QAAb,EAAuBC,YAAvB,EAAqCH,IAArC,CAAN;AAAA,GAAtB;AACA,MAAIM,gBAAgB,IAApB;;AAEA,SAAO;AACLC,SADK,mBACG;AACN,UAAID,kBAAkB,IAAtB,EAA4B;AAC1BA,wBAAgBF,eAAhB;AACD,OAFD,MAEO;AACL,YAAMI,QAAQN,SAASO,eAAT,CAAyBC,OAAzB,CAAiCC,QAAjC,EAAd;AACA;AACA;AACA;AACA,YAAI,oBAAYH,KAAZ,EAAmBI,MAAnB,GAA4B,CAAhC,EAAmC;AACjC,cAAMC,WAAW,kBAAQ,oBAAYL,KAAZ,EAAmBM,GAAnB,CAAuB,UAACC,GAAD;AAAA,mBAAS,CAACA,GAAD,EAAMP,MAAMO,GAAN,CAAN,CAAT;AAAA,WAAvB,CAAR,CAAjB;AACA;AACA;AACA;AACAb,mBAASc,cAAT,GAA0BH,QAA1B,CALiC,CAKG;AACpCX,mBAASe,iBAAT,GAA6BJ,QAA7B,CANiC,CAMM;AACxC;;AAEDP,sBAAcY,KAAd,CAAoB,YAAM;AACxBZ,0BAAgBF,eAAhB;AACD,SAFD;AAGD;AACF,KAtBI;AAuBLe,SAvBK,mBAuBG;AACN,UAAIb,kBAAkB,IAAlB,IAA0BA,cAAcI,OAA5C,EAAqD;AACnDJ,sBAAcI,OAAd,CAAsBS,KAAtB;AACD;AACF,KA3BI;AA4BLC,mBA5BK,6BA4Ba;AAChB;AACA,aAAO,mBAAMd,aAAN,EAAqB,cAArB,EAAqC,EAAEe,kBAAkB,GAApB,EAArC,CAAP;AACD;AA/BI,GAAP;AAiCD","file":"createWatchCompiler.js","sourcesContent":["// @flow\nimport _ from 'lodash';\nimport Watching from 'webpack/lib/Watching';\nimport type { Compiler } from '../types';\n\nexport type WatchCompiler = {\n  watch: () => void,\n  pause: () => void,\n  getWatchOptions: () => {\n    aggregateTimeout: number,\n    ignored?: RegExp | string,\n    poll?: number | boolean,\n  },\n}\n\nconst noop = () => undefined;\nexport default function createWatchCompiler(compiler: Compiler, watchOptions: {}): WatchCompiler {\n  // this ugly statement to create a watch compiler is unfortunately necessary,\n  // as webpack clears the file timestamps with the official compiler.watch()\n  const createWatcher = () => new Watching(compiler, watchOptions, noop);\n  let watchCompiler = null;\n\n  return {\n    watch() {\n      if (watchCompiler === null) {\n        watchCompiler = createWatcher();\n      } else {\n        const times = compiler.watchFileSystem.watcher.getTimes();\n        // check if we can store some collected file timestamps\n        // the non-empty check is necessary as the times will be reseted after .close()\n        // and we don't want to reset already existing timestamps\n        if (Object.keys(times).length > 0) {\n          const timesMap = new Map(Object.keys(times).map((key) => [key, times[key]]));\n          // set already collected file timestamps to cache compiled files\n          // webpack will do this only after a file change, but that will not happen when we add or delete files\n          // and this means that we have to test the whole test suite again ...\n          compiler.fileTimestamps = timesMap; // eslint-disable-line no-param-reassign\n          compiler.contextTimestamps = timesMap; // eslint-disable-line no-param-reassign\n        }\n\n        watchCompiler.close(() => {\n          watchCompiler = createWatcher();\n        });\n      }\n    },\n    pause() {\n      if (watchCompiler !== null && watchCompiler.watcher) {\n        watchCompiler.watcher.pause();\n      }\n    },\n    getWatchOptions() {\n      // 200 is the default value by webpack\n      return _.get(watchCompiler, 'watchOptions', { aggregateTimeout: 200 });\n    },\n  };\n}\n"]}