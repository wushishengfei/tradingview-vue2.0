{"version":3,"sources":["../../../src/webpack/compiler/registerInMemoryCompiler.js"],"names":["registerInMemoryCompiler","compiler","memoryFs","MemoryFileSystem","outputFileSystem","assetMap","hooks","done","tap","stats","clear","hasErrors","compilation","assets","forEach","assetPath","set","options","output","path","readFile","filePath","has","code","readFileSync","e","resolveFile","requireCaller","resolvedPath","filename","resolve","dirname","source","unmountHook","sourceMapSupport","install","emptyCacheBetweenOperations","handleUncaughtExceptions","environment","retrieveFile","f","unmount"],"mappings":";;;;;;;;;;;;;;kBAQwBA,wB;;AAPxB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAGe,SAASA,wBAAT,CAAkCC,QAAlC,EAAsD;AACnE;AACA,MAAMC,WAAW,IAAIC,kBAAJ,EAAjB;AACAF,WAASG,gBAAT,GAA4BF,QAA5B,CAHmE,CAG7B;;AAEtC;AACA,MAAMG,WAAW,mBAAjB;AACAJ,WAASK,KAAT,CAAeC,IAAf,CAAoBC,GAApB,CAAwB,WAAxB,EAAqC,UAACC,KAAD,EAAkB;AACrDJ,aAASK,KAAT;;AAEA,QAAI,CAACD,MAAME,SAAN,EAAL,EAAwB;AACtB,0BAAYF,MAAMG,WAAN,CAAkBC,MAA9B,EACGC,OADH,CACW,UAACC,SAAD;AAAA,eAAeV,SAASW,GAAT,CAAa,+BAAmBD,SAAnB,EAA8Bd,SAASgB,OAAT,CAAiBC,MAAjB,CAAwBC,IAAtD,CAAb,EAA0E,IAA1E,CAAf;AAAA,OADX;AAED;AACF,GAPD;;AASA;AACA,MAAIC,WAAW,kBAACC,QAAD,EAAc;AAC3B,QAAIhB,SAASiB,GAAT,CAAaD,QAAb,CAAJ,EAA4B;AAC1B,UAAI;AACF,YAAME,OAAOrB,SAASsB,YAAT,CAAsBH,QAAtB,EAAgC,MAAhC,CAAb;AACA,eAAOE,IAAP;AACD,OAHD,CAGE,OAAOE,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACF;AACD,WAAO,IAAP;AACD,GAVD;;AAYA;AACA,MAAMC,cAAc,SAAdA,WAAc,CAACL,QAAD,EAAWM,aAAX,EAA6B;AAC/C;AACA,QAAIJ,OAAOH,SAASC,QAAT,CAAX;AACA,QAAIO,eAAeP,QAAnB;;AAEA,QAAIE,SAAS,IAAT,IAAiBI,iBAAiB,IAAtC,EAA4C;AAAA,UAClCE,QADkC,GACrBF,aADqB,CAClCE,QADkC;;AAE1C,UAAIA,YAAY,IAAhB,EAAsB;AACpB;AACAD,uBAAeT,eAAKW,OAAL,CAAaX,eAAKY,OAAL,CAAaF,QAAb,CAAb,EAAqCR,QAArC,CAAf;AACAE,eAAOH,SAASQ,YAAT,CAAP;AACD;AACF;AACD,WAAO,EAAET,MAAMI,SAAS,IAAT,GAAgBK,YAAhB,GAA+B,IAAvC,EAA6CI,QAAQT,IAArD,EAAP;AACD,GAdD;;AAgBA;AACA,MAAMU,cAAc,mCAAoB,KAApB,EAA2BP,WAA3B,CAApB;;AAEA;AACAQ,6BAAiBC,OAAjB,CAAyB;AACvBC,iCAA6B,IADN;AAEvBC,8BAA0B,KAFH;AAGvBC,iBAAa,MAHU;AAIvBC,kBAAc,sBAACC,CAAD;AAAA,aAAOpB,SAASoB,CAAT,CAAP;AAAA,KAJS,CAIW;AAJX,GAAzB;;AAOA,SAAO,SAASC,OAAT,GAAmB;AACxBR;AACAb,eAAW,kBAACC,QAAD;AAAA,aAAc,IAAd;AAAA,KAAX,CAFwB,CAEO;AAChC,GAHD;AAID","file":"registerInMemoryCompiler.js","sourcesContent":["// @flow\nimport path from 'path';\nimport sourceMapSupport from 'source-map-support';\nimport MemoryFileSystem from 'memory-fs';\nimport registerRequireHook from '../../util/registerRequireHook';\nimport { ensureAbsolutePath } from '../../util/paths';\nimport type { Compiler, Stats } from '../types';\n\nexport default function registerInMemoryCompiler(compiler: Compiler) {\n  // register memory fs to webpack\n  const memoryFs = new MemoryFileSystem();\n  compiler.outputFileSystem = memoryFs; // eslint-disable-line no-param-reassign\n\n  // build asset map to allow fast checks for file existence\n  const assetMap = new Map();\n  compiler.hooks.done.tap('mochapack', (stats: Stats) => {\n    assetMap.clear();\n\n    if (!stats.hasErrors()) {\n      Object.keys(stats.compilation.assets)\n        .forEach((assetPath) => assetMap.set(ensureAbsolutePath(assetPath, compiler.options.output.path), true));\n    }\n  });\n\n  // provide file reader to read from memory fs\n  let readFile = (filePath) => {\n    if (assetMap.has(filePath)) {\n      try {\n        const code = memoryFs.readFileSync(filePath, 'utf8');\n        return code;\n      } catch (e) {\n        return null;\n      }\n    }\n    return null;\n  };\n\n  // module resolver for require calls from memory fs\n  const resolveFile = (filePath, requireCaller) => {\n    // try to read file from memory-fs as it is\n    let code = readFile(filePath);\n    let resolvedPath = filePath;\n\n    if (code === null && requireCaller != null) {\n      const { filename } = requireCaller;\n      if (filename != null) {\n        // if that didn't work, resolve the file relative to it's parent\n        resolvedPath = path.resolve(path.dirname(filename), filePath);\n        code = readFile(resolvedPath);\n      }\n    }\n    return { path: code !== null ? resolvedPath : null, source: code };\n  };\n\n  // install require hook to be able to require webpack bundles from memory\n  const unmountHook = registerRequireHook('.js', resolveFile);\n\n  // install source map support to read source map from memory\n  sourceMapSupport.install({\n    emptyCacheBetweenOperations: true,\n    handleUncaughtExceptions: false,\n    environment: 'node',\n    retrieveFile: (f) => readFile(f), // wrapper function to fake an unmount function\n  });\n\n  return function unmount() {\n    unmountHook();\n    readFile = (filePath) => null; // eslint-disable-line no-unused-vars\n  };\n}\n"]}